
const GLchar * vsSource = "#version 330\n\n//#define USE_VERTEX_COLORS\n//#define UNLIT\n\nin vec3 position;\nin vec3 normal;\nin vec3 color;\n//in vec2 uv;\n\nuniform mat4 MVP;\nuniform mat4 NormalMatrix;\nuniform vec3 DiffuseColor;\n\n// flat out vec4 Color;\nout vec4 Color;\nout vec3 vtx;\n\n\nvec4 emulate_precision_error(float factor, in vec4 pos)\n{\n    float mult = 1.0f + (1.0f - factor) * 100.0f;\n    pos = floor(pos * mult) / mult;\n    return pos;\n}\n\nvoid main()\n{\n    vec4 v_pos = vec4(position, 1.0f);\n	//gl_Position = emulate_precision_error(0.1f, MVP * v_pos);\n	gl_Position = MVP * v_pos;\n\n	vec3 col = DiffuseColor;\n	#ifdef USE_VERTEX_COLORS\n	col *= color;\n	#endif\n\n    vtx = mat3(NormalMatrix) * position + normal * 0;\n\n    // note this value is unsaturated, we would saturate with min(color, vec4(1.0)\n	Color = vec4(col, 1.0f);\n}\n";

const GLchar * fsSource = "#version 330\n\nconst vec3 ambient = vec3(0.7f, 0.7f, 0.7f);\nconst vec3 dlight = vec3(-1.0f, -1.0f, -1.0f); // direction\nconst float dfact = 0.2f; // directional light intensity\n\n//flat in vec4 Color;\nin vec4 Color;\n\nin vec3 vtx;\n\nout vec4 outputColor;\n\nvoid directional_light(vec3 surface_normal, inout vec3 scatteredLight)\n{\n    vec3 direction = normalize(dlight);\n    float diffuse = max(0.0, dot(surface_normal, direction));\n	scatteredLight += diffuse * dfact;\n}\n\nvoid main()\n{\n    #ifndef UNLIT\n	vec3 scatteredLight = ambient;\n    vec3 u = dFdx(vtx);\n    vec3 v = dFdy(vtx);\n	vec3 surface_normal = normalize(cross(u, v));\n	directional_light(surface_normal, scatteredLight);\n    #endif\n\n    outputColor = vec4(scatteredLight, 1.0) * Color;\n}\n\n";
